/*
 * This source file was generated by the Gradle 'init' task
 */
package xyz.brandonirizarry;

import xyz.brandonirizarry.primitives.Delta;
import xyz.brandonirizarry.primitives.Point;
import xyz.brandonirizarry.tetrisboard.TetrisBoard;
import xyz.brandonirizarry.tetromino.Tetromino;

import java.util.ArrayList;
import java.util.List;

import static xyz.brandonirizarry.tetromino.Tetromino.reverseRotationTable;
import static xyz.brandonirizarry.tetromino.Tetromino.rotationTable;

public class App {
    public static void main(String[] args) {
        var J1 = Tetromino.aliased("J1");

        // Let's use a smaller board for the purposes of this demonstration.
        var tetrisBoard = new TetrisBoard(6, 6);

        tetrisBoard.drawTetromino(new Point(0, 3), J1);

        System.out.println("Board after introducing J:");
        System.out.println(tetrisBoard);

        // This is where it gets interesting: I want the rotationTable
        // to kick in now.
        //
        // Note that the board is stateless over what the current
        // tetromino is. We'll find out what the current tetromino is
        // using the following code.

        List<Point> pieceCells = new ArrayList<>();

        for (var rowIndex = 0; rowIndex < tetrisBoard.numRows; rowIndex++) {
            for (var columnIndex = 0; columnIndex < tetrisBoard.numColumns; columnIndex++) {
                if (tetrisBoard.isTetrominoCell(rowIndex, columnIndex)) {
                    pieceCells.add(new Point(rowIndex, columnIndex));
                }
            }
        }

        var tetromino = Point.convertPointsToDeltas(pieceCells);
        System.out.println("We found a J tetromino: " + tetromino);

        // Now that we've found the tetromino, we can erase it in
        // preparation for drawing its next rotation.
        tetrisBoard.eraseTetromino(pieceCells.getFirst(), tetromino);

        var nextRotation = rotationTable.get(tetromino);
        var nextTetromino = nextRotation.tetromino();
        var originDelta = nextRotation.originDelta();

        tetrisBoard.drawTetromino(Point.add(pieceCells.getFirst(), originDelta), nextTetromino);

        System.out.println();
        System.out.println("Board after rotation J once counterclockwise:");
        System.out.println(tetrisBoard);

        // Now, let's see if we can translate the piece downward one
        // space.
        //
        // We should eventually have this tetromino-finding code in
        // its own method.

        pieceCells = new ArrayList<>();

        for (var rowIndex = 0; rowIndex < tetrisBoard.numRows; rowIndex++) {
            for (var columnIndex = 0; columnIndex < tetrisBoard.numColumns; columnIndex++) {
                if (tetrisBoard.isTetrominoCell(rowIndex, columnIndex)) {
                    pieceCells.add(new Point(rowIndex, columnIndex));
                }
            }
        }

        // What's amazing about this is that we don't need new logic
        // to handle translation: we simply treat it as a "degenerate
        // case" of a rotation.
        tetromino = Point.convertPointsToDeltas(pieceCells);
        tetrisBoard.eraseTetromino(pieceCells.getFirst(), tetromino);
        tetrisBoard.drawTetromino(Point.add(pieceCells.getFirst(), new Delta(1, 0)), tetromino);

        System.out.println();
        System.out.println("Board after moving J down one space:");
        System.out.println(tetrisBoard);

        // Let's rotate it again.
        pieceCells = new ArrayList<>();

        for (var rowIndex = 0; rowIndex < tetrisBoard.numRows; rowIndex++) {
            for (var columnIndex = 0; columnIndex < tetrisBoard.numColumns; columnIndex++) {
                if (tetrisBoard.isTetrominoCell(rowIndex, columnIndex)) {
                    pieceCells.add(new Point(rowIndex, columnIndex));
                }
            }
        }

        tetromino = Point.convertPointsToDeltas(pieceCells);
        System.out.println("We found a J tetromino: " + tetromino);

        // Now that we've found the tetromino, we can erase it in
        // preparation for drawing its next rotation.
        tetrisBoard.eraseTetromino(pieceCells.getFirst(), tetromino);


        nextRotation = rotationTable.get(tetromino);
        nextTetromino = nextRotation.tetromino();
        originDelta = nextRotation.originDelta();

        tetrisBoard.drawTetromino(Point.add(pieceCells.getFirst(), originDelta), nextTetromino);

        System.out.println();
        System.out.println("Board after another rotation of J:");
        System.out.println(tetrisBoard);

        // Finally, let's attempt a clockwise rotation back to the
        // previous orientation.

        pieceCells = new ArrayList<>();

        for (var rowIndex = 0; rowIndex < tetrisBoard.numRows; rowIndex++) {
            for (var columnIndex = 0; columnIndex < tetrisBoard.numColumns; columnIndex++) {
                if (tetrisBoard.isTetrominoCell(rowIndex, columnIndex)) {
                    pieceCells.add(new Point(rowIndex, columnIndex));
                }
            }
        }

        tetromino = Point.convertPointsToDeltas(pieceCells);
        System.out.println("We found a J tetromino: " + tetromino);

        // Now that we've found the tetromino, we can erase it in
        // preparation for drawing its next rotation.
        tetrisBoard.eraseTetromino(pieceCells.getFirst(), tetromino);


        nextRotation = reverseRotationTable.get(tetromino);
        nextTetromino = nextRotation.tetromino();
        originDelta = nextRotation.originDelta();

        tetrisBoard.drawTetromino(Point.add(pieceCells.getFirst(), originDelta), nextTetromino);

        System.out.println();
        System.out.println("Board after rotating clockwise to previous orientation:");
        System.out.println(tetrisBoard);
    }
}
